/**
 ******************************************************************************
 * @file    main.c
 * @author  Gideon Fulton, Emiliano, Alejandro Barroso, Patrick Hadiwinoto
 * @date    October 25, 2024
 * @brief   ECE 362 Team 51 Project
 ******************************************************************************
*/

//added "${workspaceFolder}/.pio/packages/framework-cmsis/Device/ST/STM32F0xx/Include" to includePath in c_cpp_properties.json
//added "STM32F091" to defines in c_cpp_properties.json

#include "stm32f0xx.h"
//#include "stm32f091xc.h" //added instead of above include
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "commands.h"

void nano_wait(unsigned int);
//void game(void);
void internal_clock();
void check_wiring();
void autotest();
void setn(int32_t, int32_t);
int32_t readpin(int32_t);
void buttons();
void setup_tim7_for_inputs();
void small_delay();

void init_spi1();
void spi_cmd(unsigned int);
void spi_data(unsigned int);
void spi1_init_oled();
void spi1_display1(const char*);
void spi1_display2(const char*);
void spi1_clear_display();
void update_oled_display(const char*, const char*);
void init_tim15();
void init_tim16();
void setup_bb();
void update_display(int d1, int d2, int d3, int d4);

uint16_t msg[8] = { 0x0000,0x0100,0x0200,0x0300,0x0400,0x0500,0x0600,0x0700 };

#if 0
   #define WIDTH 32
   #define HEIGHT 32

   typedef struct {
      int x;
      int y;
   } Point;

   typedef struct {
      //Point segments[(HEIGHT - 2) * (WIDTH - 2)]; //maybe should be 32*32 for our matrix or 30*30 since the wall takes up 2 pixels each row
      Point segments[665]; 
      int length; //do we need this?
      char direction;
   } Snake;

   int gameOver = 0;
   Snake snake;
   Point food;

   //===========================================================================
   // Configure All Ports
   //===========================================================================
   void enable_ports(void) {
      RCC->AHBENR |= RCC_AHBENR_GPIOCEN; 

      //enable PC1-PC3 for input and PC4-PC7 and PC0 for output
      GPIOC->MODER &= ~0x0000ffff;
      GPIOC->MODER |= 0x00005501;

      //simulate pull down resistors for PC0-PC3
      //also have mechanical pull down resistors in place just in case
      GPIOC->PUPDR &= ~0x000000ff;
      GPIOC->PUPDR |= 0x000000a8;

   }


   void small_delay(void) {
      nano_wait(50000);
   }

   //===========================================================================
   // Bit Bang SPI LED Array
   //===========================================================================
   int msg_index = 0;
   extern const char font[];
   uint8_t col; // the column being scanned

   //===========================================================================
   // This is the 34-entry buffer to be copied into SPI1.
   // Each element is a 16-bit value that is either character data or a command.
   // Element 0 is the command to set the cursor to the first position of line 1.
   // The next 16 elements are 16 characters.
   // Element 17 is the command to set the cursor to the first position of line 2.
   //===========================================================================
   uint16_t display[34] = {
         0x002, // Command to set the cursor at the first position line 1
         0x200+'E', 0x200+'C', 0x200+'E', 0x200+'3', 0x200+'6', + 0x200+'2', 0x200+' ', 0x200+'i',
         0x200+'s', 0x200+' ', 0x200+'t', 0x200+'h', + 0x200+'e', 0x200+' ', 0x200+' ', 0x200+' ',
         0x0c0, // Command to set the cursor at the first position line 2
         0x200+'c', 0x200+'l', 0x200+'a', 0x200+'s', 0x200+'s', + 0x200+' ', 0x200+'f', 0x200+'o',
         0x200+'r', 0x200+' ', 0x200+'y', 0x200+'o', + 0x200+'u', 0x200+'!', 0x200+' ', 0x200+' ',
   };




   //4 digit 8 segment display
   void setup_bb(void) {

      RCC -> AHBENR |= RCC_AHBENR_GPIOBEN;

      GPIOB -> MODER &= ~0xcf000000;
      
      GPIOB -> MODER |=  0x45000000;
      
      GPIOB -> BSRR |= (1 << 12) | (1 << (13 + 16));

   }

   void bb_write_bit(int val) {

      // CS (PB12)
      // SCK (PB13)
      // SDI (PB15)

      if (val != 0) {
         GPIOB -> BSRR = 1 << 15;
      }
      else {
         GPIOB -> BRR = 1 << 15;
      }

      //small_delay();
      GPIOB -> BSRR = 1 << 13;

      //small_delay();
      GPIOB -> BRR = 1 << 13;
      
   }

   void bb_write_halfword(int halfword) {
      GPIOB -> BRR = 1 << 12;    //Set CS (PB12) low to begin transmission

      for (int i = 15; i >= 0; i--) { //Loop through each bit from 15 down to 0
         bb_write_bit((halfword >> i) & 1);  //Shift right and mask with 1 to isolate each bit
      }

      GPIOB -> BSRR = 1 << 12;     //Set CS (PB12) high to end transmission
   }

   // void init_tim16(void) {
   //     // Enable the RCC clock for TIM16
   //     RCC->APB2ENR |= RCC_APB2ENR_TIM16EN;

   //     // Set prescaler and auto-reload value for 1 kHz timer frequency
   //     TIM16->PSC = 48000 - 1;       // Prescaler to divide clock to 48 kHz
   //     TIM16->ARR = 1000 - 1;     // Auto-reload for 1 ms intervals

   //     // Enable update interrupt
   //     TIM16->DIER |= TIM_DIER_UIE; // Enable update interrupt

   //     // Enable the interrupt in the NVIC
   //     NVIC_SetPriority(TIM16_IRQn, 0);
   //     NVIC_EnableIRQ(TIM16_IRQn);

   //     // Start the timer
   //     TIM16->CR1 |= TIM_CR1_CEN;
   // }


   // int countdown_seconds = 120;
   // void TIM16_IRQHandler() {
   //    TIM16->SR &= ~TIM_SR_UIF;

   //    countdown_seconds--;

   //    int minutes = countdown_seconds / 60;
   //    int secs = countdown_seconds % 60;

   //    int digit1 = (minutes / 10) + '0';  // Tens place of minutes
   //    int digit2 = (minutes % 10) + '0';  // Units place of minutes
   //    int digit3 = (secs / 10) + '0';      // Tens place of seconds
   //    int digit4 = (secs % 10) + '0';      // Units place of seconds
      
      
   //    msg[0] |= font[' '];
   //     msg[1] |= font[' '];
   //     msg[2] |= font[' '];
   //     msg[3] |= font[' '];
   //     msg[4] |= font[digit1];
   //     msg[5] |= font[digit2];
   //     msg[6] |= font[digit3];
   //     msg[7] |= font[digit4];
   // }  




   void setn(int32_t pin_num, int32_t val) {
      if (val == 0) {
      GPIOC->BRR = ((0x00000001 << pin_num));
      }
      else {
      GPIOC->BSRR = (0x00000001 << pin_num);
      }
   }

   int32_t readpin(int32_t pin_num) {
      return (GPIOC->IDR & (1 << pin_num)) ? 1 : 0;
   }

   void buttons(void) {
      // int32_t pc0 = readpin(0);
      // int32_t pc1 = readpin(1);
      // int32_t pc2 = readpin(2);
      // int32_t pc3 = readpin(3);

      // setn(4, pc0);
      // setn(5, pc1);
      // setn(6, pc2);
      // setn(7, pc3);

      int32_t pc8 = readpin(8);
      int32_t pc9 = readpin(9);
      int32_t pc10 = readpin(10);
      int32_t pc11 = readpin(11);

      // setn(4, pc8);
      // setn(5, pc9);
      // setn(6, pc10);
      // setn(7, pc11);

      if (pc8 == 1 && snake.direction != 'w') {
         snake.direction = 'e';
      }
      else if (pc9 == 1 && snake.direction != 'n') {
         snake.direction = 's';
      }
      else if (pc11 == 1 && snake.direction != 'e') {
         snake.direction = 'w';
      }
      else if (pc10 == 1 && snake.direction != 's') {
         snake.direction = 'n';
      }
   }

   int d = 0;
   void TIM7_IRQHandler() {
      TIM7->SR &= ~TIM_SR_UIF;

      buttons();

      // bb_write_halfword(msg[4 + d]);

      // d++;
      // if (d >= 4) {
      //    d = 0;  // Loop back to the first digit
      // }

      bb_write_halfword(msg[4+d]);
      //nano_wait(250000);

      //bb_write_halfword(msg[6+d]);

      d++; //4+0, 4+1, 4+2, 4+3, 4+4->4+0
      if (d == 4) {
         d = 0;
      }



      // // for(int d=0; d<8; d++) {
      // //    bb_write_halfword(msg[d]);
      // //    //nano_wait(1000000); //1ms
      // //    nano_wait(50000);
      // // }

      // GPIOB->BRR = 0xF << 12;  // Adjust this based on your digit enable pins

      //  // Write data to the current digit
      //  bb_write_halfword(msg[d]);

      //  // Enable the current digit (active-low example)
      //  GPIOB->BSRR = (1 << (12 + d)); // Adjust for your digit enable pins

      //  // Move to the next digit
      //  d++;
      //  if (d >= 8) {
      //      d = 0;  // Loop back to the first digit
      //  }
   } 

   void setup_tim7_for_inputs() {
   //Enable the RCC clock for TIM7.
   RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;

   //Enable the UIE bit in the DIER to enable the UIE flag 
   //(use the symbol TIM_DIER_UIE for this). 
   //This will enable an update interrupt to occur each time 
   //the free-running counter of the timer reaches the ARR value 
   //and starts back at zero.             
   TIM7->DIER |= TIM_DIER_UIE;

   //Enable the interrupt for Timer 7 in the NVIC ISER.
   NVIC->ISER[0] |= (1 << TIM7_IRQn);

   NVIC_SetPriority(TIM7_IRQn,0);

   //Enable Timer 7 by setting the CEN bit in the Timer 7 Control Register 1.
   //(Set TIM_CR1_CEN in TIM7_CR1.)
   TIM7->CR1 |= TIM_CR1_CEN;
   }



   void init_spi1() {
   //Enable the clock for GPIOA and SPI1
   RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;  //Enable SPI1 clock
   RCC->AHBENR |= RCC_AHBENR_GPIOAEN;   //Enable GPIOA clock

   //Set PA5, PA7, PA15 to alternate function mode (0x02)
   GPIOA->MODER &= ~(GPIO_MODER_MODER15_Msk | GPIO_MODER_MODER5_Msk | GPIO_MODER_MODER7_Msk); //Clear mode bits
   GPIOA->MODER |= (GPIO_MODER_MODER15_1 | GPIO_MODER_MODER5_1 | GPIO_MODER_MODER7_1); //Set to AF mode

   //Set Alternate Function to AF0 (for SPI1)
   GPIOA->AFR[0] &= ~((0xf << 20) | (0xf << 28));  //Clear AFR bits for PA5 (AF0) and PA7 (AF0)
   GPIOA->AFR[0] |= (0x0 << 20) | (0x0 << 28);      //Set AF0 for PA5 and PA7
   GPIOA->AFR[1] &= ~(0xf << 28);                    //Clear AFR bits for PA15
   GPIOA->AFR[1] |= (0x0 << 28);                     //Set AF0 for PA15

   //Disable SPI1 before configuring
   SPI1->CR1 &= ~SPI_CR1_SPE;

   //Set the baud rate to the maximum (prescaler)
   SPI1->CR1 |= (0x7 << SPI_CR1_BR_Pos); //Set baud rate prescaler (division factor)

   SPI1->CR2 = (SPI1->CR2 & ~(SPI_CR2_DS_Msk)) | (0x9 << SPI_CR2_DS_Pos);

   SPI1->CR1 |= SPI_CR1_MSTR | SPI_CR1_SPE;
   SPI1->CR2 |= SPI_CR2_NSSP | SPI_CR2_SSOE | SPI_CR2_TXDMAEN;
   }

   void spi_cmd(unsigned int data) {
      //Wait until SPI1 TX is empty
      while ((SPI1->SR & SPI_SR_TXE) == 0) {
         //Busy wait until transmit buffer is empty
      }
      //Send the command
      SPI1->DR = data; //Write data to data register
   }

   void spi_data(unsigned int data) {
      spi_cmd(data | 0x200); //Call spi_cmd with (data | 0x200)
   }

   void spi1_init_oled() {
      nano_wait(1000000); //Wait 1 ms

      spi_cmd(0x38); //Function set
      spi_cmd(0x08); //Display off
      spi_cmd(0x01); //Clear display
      nano_wait(2000000); //Wait 2 ms
      spi_cmd(0x06); //Entry mode set
      spi_cmd(0x00); //Move cursor to home position //0x02
      spi_cmd(0x0c); //Display on
   }

   void spi1_display1(const char *string) {
      spi_cmd(0x80); //Move cursor to home position //0x00

      //Loop through each character in the string
      while (*string != '\0') {
         spi_data(*string); //Send character to the display
         string = string + 1;
      }
   }

   void spi1_display2(const char *string) {
      spi_cmd(0xc0); //Move cursor to second row

      //Loop through each character in the string
      while (*string != '\0') {
         spi_data(*string); //Send character to the display
         string = string + 1;
      }
   }

   /*
   void spi1_clear_display() {
      spi_cmd(0x01);  //Clear display command
      nano_wait(3000000); //Wait 3 ms for the command to process
   }
   */

   // void update_display(int d1, int d2, int d3, int d4) {
   //     // Send digit patterns to the 7-segment display
   //     // Replace the following with your specific display logic
      
   // }

   void update_oled_display(const char* line1, const char* line2) {
      //spi1_clear_display();
      spi1_display1(line1);
      spi1_display2(line2);
   }

   int final_score = 0;
   int high_score = 0;
   int countdown_seconds = 30;

   void TIM2_IRQHandler(void) {
      //Acknowledge the interrupt by clearing the interrupt flag
      TIM2->SR &= ~TIM_SR_UIF;
      
   // SHOULD BE RUN AT THE END OF THE GAME
   //    if(final_score > high_score){
   //         mount();
   //         write_score_to_file(final_score);
   //     }
      
      char high_score_str[17] = "High Score:     ";

      // Call the function to get the high score as an integer
      if(high_score == 0){
      mount();
      high_score = read_first_line();
      }
      if (high_score != 0) {
         // Format the score into high_score_str after "High Score: "
         snprintf(high_score_str + 12, 5, "%d", high_score);
      } else {
         printf("Could not load high score.\n");
      }

      char final_score_str[17] = "Final Score:    ";

      //strncpy(high_score_str, "High Score: ", 12); //strncpy might be too long for an isr
      //strncpy(final_score_str, "Final Score: ", 13);

      //TODO: LOGIC FOR RETRIEVING HIGH SCORE GOES HERE

      final_score = final_score + 1;

      int temp_score = final_score;
      final_score_str[15] = (temp_score % 10) + '0'; // Last digit
      temp_score /= 10;
      final_score_str[14] = (temp_score > 0) ? (temp_score % 10) + '0' : ' '; // Middle digit or space
      temp_score /= 10;
      final_score_str[13] = (temp_score > 0) ? (temp_score % 10) + '0' : ' '; // First digit or space


      update_oled_display(high_score_str, final_score_str);


      if (countdown_seconds > 0) {
         countdown_seconds--;
      }

            


      int temp_sec = countdown_seconds;

      int minutes = temp_sec / 60;
      int secs = temp_sec % 60;

      int temp_mins = minutes;
      int temp_secs = secs;

      int digit1 = (temp_mins / 10) + '0';  // Tens place of minutes
      int digit2 = (temp_mins % 10) + '0';  // Units place of minutes
      int digit3 = (temp_secs / 10) + '0';      // Tens place of seconds
      int digit4 = (temp_secs % 10) + '0';      // Units place of seconds

      // memset(msg, 0, sizeof(msg));

      // msg[0] = 0x0000;
      // msg[1] = 0x0100;
      // msg[2] = 0x0200;
      // msg[3] = 0x0300;
      msg[4] = 0x0400;
      msg[5] = 0x0500;
      msg[6] = 0x0600;
      msg[7] = 0x8700;
      
      
      // msg[0] |= font[' '];
      // msg[1] |= font[' '];
      // msg[2] |= font[' '];
      // msg[3] |= font[' '];
      msg[4] |= font[digit1];
      msg[5] |= font[digit2];
      msg[6] |= font[digit3];
      msg[7] |= font[digit4];
      
   }


   void init_tim2(void) {
      //final_score = 0;

      RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

      TIM2->PSC = 999;  
      TIM2->ARR = 47999; 

      TIM2->DIER |= TIM_DIER_UIE;

      TIM2->CR1 |= TIM_CR1_CEN;

      NVIC_EnableIRQ(TIM2_IRQn);
   }

   //------------------------------------------------------------------------------------------------------
   //interacting with LED matrix
   //------------------------------------------------------------------------------------------------------

   // Pin-out on GPIOB to display
   #define LED_A   0       // Row select A (GPIOB 0)
   #define LED_B   1       // Row select B (GPIOB 1)
   #define LED_C   2       // Row select C (GPIOB 2)
   #define LED_D   3       // Row select D (GPIOB 3)
   #define LED_LAT 4       // Latch signal to indicate end of data (GPIOB 4)
   #define LED_CLK 5       // Clock signal (GPIOB 5)
   #define LED_OE  6       // Output enable (GND to turn on, VCC to turn off) (GPIOB 6)
   #define LED_B2  7       // Bottom half blue (GPIOB 7)

   // Pin-out on GPIOA to display
   #define LED_R1  8       // Top half red (GPIOA 8)
   #define LED_G1  9       // Top half green (GPIOA 9)
   #define LED_B1  10      // Top half blue (GPIOA 10)
   #define LED_R2  11      // Bottom half red (GPIOA 11)
   #define LED_G2  12      // Bottom half green (GPIOA 12)

   int counter = 0;
   int speed_reload_num = 19;

   void setup_pins() {
      // Enable GPIOA and GPIOB clocks
      RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN;

      // Configure GPIOA Pin 8-12 as outputs
      GPIOA->MODER &= ~(0x3FF << 16);
      GPIOA->MODER |= 0b0101010101 << 16;

      // Configure GPIOB Pin 0-7 as outputs
      GPIOB->MODER &= ~(0xFFFF);  // Clear bits for PB0-PB6
      GPIOA->MODER &= ~(0x3ff << 16);
      GPIOA->MODER |= 0b0101010101 << 16;

      // Configure GPIOB Pin 0-7 as outputs
      GPIOB->MODER &= ~(0xffff);  // Clear bits for PB0-PB6
      GPIOB->MODER |= 0b0101010101010101;  // Set as outputs
   }

   void digitalWrite(GPIO_TypeDef* GPIOx, uint16_t Pin, int value) {
      if (value) {
         GPIOx->BSRR = 1 << Pin;  // Set the pin (BSRR register)
      } else {
         GPIOx->BRR = 1 << Pin;   // Reset the pin (BRR register)
      }
   }



   int EmiMap[] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,1,
                  1,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,
                  1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,
                  1,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,
                  1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,0,0,0,1,
                  1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,1,0,0,1,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,1,
                  1,0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,
                  1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,1,0,1,
                  1,0,0,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,
                  1,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0,0,1,1,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};

   int redMap[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
                  
   int greenMap[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

   int blueMap[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

   int redGameOverMap[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,
                  0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,
                  0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,
                  0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,
                  0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,0,1,0,0,0,1,1,1,1,1,0,
                  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,
                  0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,
                  0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,
                  0,0,1,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
                  0,0,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,
                  0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
                  0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,
                  0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,0,0,0,1,1,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,0,1,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

   int greenGameOverMap[]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
                  

   int blueGameOverMap[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,
                  0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,
                  0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,
                  0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,
                  0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,0,1,0,0,0,1,1,1,1,1,0,
                  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,
                  0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,
                  0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,
                  0,0,1,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
                  0,0,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,
                  0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};               

   int emptyMap[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  

   void initializeGame() {
      GPIOC->BSRR = 0x1;

      snake.length = 3;
      snake.segments[0].x = WIDTH / 2;
      snake.segments[0].y = HEIGHT / 2;
      snake.segments[1].x = WIDTH / 2;
      snake.segments[1].y = HEIGHT / 2 + 1;
      snake.segments[2].x = WIDTH / 2;
      snake.segments[2].y = HEIGHT / 2 + 2;   

      snake.direction = 'n';

      srand(high_score);
      
      food.x = (rand() % (WIDTH - 2)) + 1; //generates random index in [1,30]
      food.y = (rand() % (WIDTH - 2)) + 1;

      for(int x = 0; x<WIDTH; x++){
         for(int y=0;y<HEIGHT;y++){
            if(x == 0 || x == 31 || y ==0 || y ==31){
               blueMap[y*32+x] = 1;
            }
         }
      }
   }

   int should_increase_speed_counter = 0;


   void moveSnake() {
      Point nextPos = snake.segments[0];
      switch (snake.direction) {
         case 'n': 
            nextPos.y--; 
            break;  // Up
         case 's': 
            nextPos.y++; 
            break;  // Down
         case 'w': 
            nextPos.x--; 
            break;  // Left
         case 'e': 
            nextPos.x++; 
            break;  // Right
      }

      for (int i = snake.length - 1; i > 0; i--) {
         //shift all elements in snake segments array to the right one index
         snake.segments[i] = snake.segments[i - 1]; //since length has not been updated, the rightmost shifted element (tail) gets shifted past what is displayed
      }
      snake.segments[0] = nextPos; //set head to the next position (head is snake.segments[0])

      // Check if snake ate food
      if (snake.segments[0].x == food.x && snake.segments[0].y == food.y) { //update 4 digit 7 seg
         snake.length++;
         countdown_seconds = countdown_seconds + 6;
         if (speed_reload_num > 0 && should_increase_speed_counter == 10) { //increases game speed. This logic can be motified
            speed_reload_num--;
            should_increase_speed_counter = -1;
         }
         should_increase_speed_counter++;


         // LOOP DO-WHILE CAUSING PROBLEMS
         int food_in_snake = 0;
         srand(final_score);
         do {
            food_in_snake = 0;
            food.x = (rand() % (WIDTH - 2)) + 1; //generates random index in [1,30]
            food.y = (rand() % (WIDTH - 2)) + 1;
            int foodIdx = food.x + food.y*32;
            
            if (redMap[foodIdx] == 1 || greenMap[foodIdx] == 1) {
               food_in_snake = 1;
            }
            
         } while (food_in_snake);
      }
   }

   int checkCollision() {
      if ((snake.segments[0].x <= 0) || (snake.segments[0].x >= (WIDTH - 1)) || (snake.segments[0].y <= 0) || (snake.segments[0].y >= (HEIGHT - 1))) {
         return 1;  // Wall collision
      }
      for (int i = 1; i < snake.length; i++) {
         if ((snake.segments[0].x == snake.segments[i].x) && (snake.segments[0].y == snake.segments[i].y)) {
            return 1;  // Self-collision
         }
      }
      return 0;
   }

   void updateRGBMaps() {
      
      if(!gameOver){
         //RESET ALL MAPS TO 0
         memset(redMap, 0, (32*32)*sizeof(redMap[0]));
         // memset(blueMap, 0, (32*32)*sizeof(blueMap[0]));
         memset(greenMap, 0, (32*32)*sizeof(greenMap[0]));

         int gameIdx = 0;
         // CHANGE TO 1 FOOD PIXEL
         int foodIdx = food.x+food.y*32;
         redMap[foodIdx] = 1;
         blueMap[foodIdx] = 1;

         //SET SNAKE HEAD PIXEL TO 1
         int headIdx = snake.segments[0].x + snake.segments[0].y*32;
         greenMap[headIdx] = 0;
         redMap[headIdx] = 1;
         blueMap[headIdx] = 0;
         //SET SNAKE BODY PIXEL TO 1
         for (int i = 1; i < snake.length; i++) {
            int x = snake.segments[i].x;
            int y = snake.segments[i].y;
            gameIdx = x+y*32;
            if(gameIdx != 0){
            redMap[gameIdx] = 0;
            greenMap[gameIdx] = 1;
            blueMap[gameIdx] = 0;
            }
      }
         
         //Transforms coordinates to array index
         // if (y == 0 || y == (HEIGHT - 1) || x == 0 || x == (WIDTH - 1)) { //current pixel is part of wall
         //    redMap[gameIdx] = 0;
         //    greenMap[gameIdx] = 0;
         //    blueMap[gameIdx] = 1;
         // }
         // else if (snake.segments[0].x == x && snake.segments[0].y == y) { //current pixel is snake head
         //    redMap[gameIdx] = 1;
         //    greenMap[gameIdx] = 0;
         //    blueMap[gameIdx] = 0;               
         // }
         // else if (y == food.y && x == food.x) { //current pixel is food
         //    redMap[gameIdx] = 1;
         //    greenMap[gameIdx] = 0;
         //    blueMap[gameIdx] = 1;
         // }
         // else { //current pixel is snake body (not head) or background
         //    int isBodyPart = 0;
         //    for (int i = 1; i < snake.length; i++) {
         //       if (snake.segments[i].x == x && snake.segments[i].y == y) { //check if current pixel is part of snake.segments array (not head though, which is snake.segments[0])
         //          isBodyPart = 1;
         //          break;
         //       }
         //    }
         //    if (isBodyPart) { //current pixel is part of snake body
               // redMap[gameIdx] = 0;
               // greenMap[gameIdx] = 1;
               // blueMap[gameIdx] = 0;
         //    }
         //    else { //current pixel is background
         //    redMap[gameIdx] = 0;
         //    greenMap[gameIdx] = 0;
         //    blueMap[gameIdx] = 0;
         //    }
         // }
         // gameIdx++;
      
      }
   }


   //BELOW: an attempt to make code more efficient (O(n^2) instead of O(n^3))
   /*
   void updateRGBMaps() {
      int gameIdx = 0;
      for (int y = 0; y < HEIGHT; y++) {
         for (int x = 0; x < WIDTH; x++) {
            if (y == 0 || y == 31 || x == 0 || x == 31) { //current pixel is part of wall
               redMap[gameIdx] = 0;
               greenMap[gameIdx] = 0;
               blueMap[gameIdx] = 1;
            }
            else if (snake.segments[0].x == x && snake.segments[0].y == y) { //current pixel is snake head
               redMap[gameIdx] = 1;
               greenMap[gameIdx] = 0;
               blueMap[gameIdx] = 0;               
            }
            else if (y == food.y && x == food.x) { //current pixel is food
               redMap[gameIdx] = 1;
               greenMap[gameIdx] = 0;
               blueMap[gameIdx] = 1;
            }
            else { //current pixel is snake body (not head) or background
               redMap[gameIdx] = 0;
               greenMap[gameIdx] = 0;
               blueMap[gameIdx] = 0;
            }
            gameIdx++;
         }
      }

      //add in snake body
      for (int idx = 1; idx < snake.length; idx++) {
         greenMap[WIDTH * snake.segments[idx].y + snake.segments[idx].x] = 1;
      }
   }
   */





   void displayCurrentMaps() {
      for (int row = 0; row < 16; row++) { //go through 16 rows (2 rows displayed at a time eg row 0 and row 16 or row 1 and row 17)
         // Disable output while setting row data
         digitalWrite(GPIOB, LED_OE, 0b1);

         // Set row address
         digitalWrite(GPIOB, LED_A, (row >> 0) & 0x1);
         digitalWrite(GPIOB, LED_B, (row >> 1) & 0x1);
         digitalWrite(GPIOB, LED_C, (row >> 2) & 0x1);
         digitalWrite(GPIOB, LED_D, (row >> 3) & 0x1);

         // Shift color data for each LED in the row
         for (int i = 0; i < 32; i++) { //go through and send each bit in given row (32 bits in total)
            // Set R1 and R2 based on redMap array
            digitalWrite(GPIOA, LED_R1, redMap[row * WIDTH + i]);
            digitalWrite(GPIOA, LED_R2, redMap[(row + (HEIGHT / 2)) * WIDTH + i]);

            digitalWrite(GPIOA, LED_G1, greenMap[row * WIDTH + i]);
            digitalWrite(GPIOA, LED_G2, greenMap[(row + (HEIGHT / 2)) * WIDTH + i]);

            digitalWrite(GPIOA, LED_B1, blueMap[row * WIDTH + i]);
            digitalWrite(GPIOB, LED_B2, blueMap[(row + (HEIGHT / 2)) * WIDTH + i]);

            // Clock pulse
            digitalWrite(GPIOB, LED_CLK, 0b1); //clock bit in
            nano_wait(250); // Adjust this if clock speed needs to be higher
            digitalWrite(GPIOB, LED_CLK, 0b0);
         }

         // Latch data to display the row
         digitalWrite(GPIOB, LED_LAT, 0b1);
         nano_wait(250);  // Short delay to ensure latch
         digitalWrite(GPIOB, LED_LAT, 0b0);

         // Enable output for the current row display
         digitalWrite(GPIOB, LED_OE, 0b0);
         nano_wait(350000); // Adjust this delay to control row display time
         //nano_wait(300000);
      }
   }
   int checkHigh = 0;
   void cmp_final_score() {
      if((final_score > high_score) && (checkHigh == 0)){
         write_score_to_file(final_score);
         high_score = final_score;
         checkHigh =1;
      }
   }

   int current_digit = 0;
   void TIM14_IRQHandler(void) {
      //Acknowledge the interrupt
      TIM14->SR &= ~TIM_SR_UIF;

      //need to make it so that pressing the buttons causes the snake direction to change
      //changing the snake direction will cause the moveSnake function to update the snake coordinates in that direction
      //it will default to moving the snake in the current saved direction

      if (counter >= speed_reload_num) {
         moveSnake(); //move snake positioning and take care of eating food
         //need to add time to 4 digit 8 segment display when food is eaten
      }

      if (checkCollision() || countdown_seconds == 0) { //game has ended
         gameOver = 1;
         msg[0] = 0x0000;
         msg[1] = 0x0100;
         msg[2] = 0x0200;
         msg[3] = 0x0300;
         msg[4] = 0x0400;
         msg[5] = 0x0500;
         msg[6] = 0x0600;
         msg[7] = 0x8700;
         msg[7] |= font['0'];
         bb_write_halfword(msg[7]);
         GPIOC->BRR = 0x1;

         TIM7->DIER &= ~TIM_DIER_UIE;
         //high score here
         cmp_final_score();
         TIM2->DIER &= ~TIM_DIER_UIE;

         //TIM14->DIER &= ~TIM_DIER_UIE;

         memcpy(redMap, redGameOverMap, sizeof(redMap));
         memcpy(greenMap, greenGameOverMap, sizeof(greenMap));
         memcpy(blueMap, blueGameOverMap, sizeof(blueMap));
         //nano_wait(500000);
         displayCurrentMaps();
         //maybe disable more interrupts
      }

      if (counter >= speed_reload_num) {
         updateRGBMaps(); //creates the new r g and b maps for new snake position
         counter = -1;
      }
      displayCurrentMaps();
      counter++;
   }

   //BELOW: an attempt to stop game map right before snake dies from being displayed after the game ends
   //not sure if it will fix the issue with the snake stopping whenever it collides with food
   /*
   int gameOver = 0;
   void TIM14_IRQHandler(void) {
      //Acknowledge the interrupt
      TIM14->SR &= ~TIM_SR_UIF;

      //need to make it so that pressing the buttons causes the snake direction to change
      //changing the snake direction will cause the moveSnake function to update the snake coordinates in that direction
      //it will default to moving the snake in the current saved direction

      if ((counter == speed_reload_num) && !gameOver) {
         moveSnake(); //move snake positioning and take care of eating food
         //need to add time to 4 digit 8 segment display when food is eaten
      }

      if (checkCollision()) { //game has ended
         gameOver = 1;

         TIM7->DIER &= ~TIM_DIER_UIE;
         //high score here
         cmp_final_score();
         TIM2->DIER &= ~TIM_DIER_UIE;

         //TIM14->DIER &= ~TIM_DIER_UIE;

         memcpy(redMap, redGameOverMap, sizeof(redMap));
         memcpy(greenMap, greenGameOverMap, sizeof(greenMap));
         memcpy(blueMap, blueGameOverMap, sizeof(blueMap));
         //counter--; //counld add to keep counter constant when game ends, but i dont think there is any need

         //maybe disable more interrupts
      }

      if ((counter == speed_reload_num) && !gameOver) {
         updateRGBMaps(); //creates the new r g and b maps for new snake position
         counter = -1;
      }
      displayCurrentMaps();
      counter++; //counter might overrun buffer when game ends, but i dont think that will cause any issues (i hope)
   }

   */

   void init_tim14() { //100Hz interrupt
      RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;
      TIM14->PSC = 479;
      TIM14->ARR = 999; //999
      TIM14->DIER |= TIM_DIER_UIE;
      NVIC->ISER[0] |= (1 << TIM14_IRQn);
      NVIC_SetPriority(TIM14_IRQn,1);

      TIM14->CR1 |= TIM_CR1_CEN;
   }





   /*

   int main() {
      initializeGame();
      while (1) {
         if (_kbhit()) {
               char key = _getch();
               if ((key == 'w' && snake.direction != 's') || 
                  (key == 's' && snake.direction != 'w') ||
                  (key == 'a' && snake.direction != 'd') || 
                  (key == 'd' && snake.direction != 'a')) {
                  snake.direction = key;
               }
         }
         
         moveSnake();
         if (checkCollision()) break;
         
         drawBoard();
         Sleep(100);  // Control the game speed
      }
      
      printf("Game Over! Your score is: %d\n", snake.length - 1);
      return 0;
   }

   */









   void trial_run() {
      setup_pins();

      // Set stable row and turn off LEDs
      digitalWrite(GPIOB, LED_A, 0b0); 
      digitalWrite(GPIOB, LED_B, 0b0); 
      digitalWrite(GPIOB, LED_C, 0b0); 
      digitalWrite(GPIOB, LED_D, 0b0); 

      // Set green and blue LEDs off
      digitalWrite(GPIOA, LED_G1, 0b0);
      digitalWrite(GPIOA, LED_B1, 0b0);
      digitalWrite(GPIOA, LED_G2, 0b0);
      digitalWrite(GPIOB, LED_B2, 0b0);

      while (1) {
         for (int row = 0; row < 16; row++) { //go through 16 rows (2 rows displayed at a time eg row 0 and row 16 or row 1 and row 17)
            // Disable output while setting row data
            digitalWrite(GPIOB, LED_OE, 0b1);

            // Set row address
            digitalWrite(GPIOB, LED_A, (row >> 0) & 0x1);
            digitalWrite(GPIOB, LED_B, (row >> 1) & 0x1);
            digitalWrite(GPIOB, LED_C, (row >> 2) & 0x1);
            digitalWrite(GPIOB, LED_D, (row >> 3) & 0x1);

            nano_wait(1000); // Small delay to allow row setup

            // Shift color data for each LED in the row
            for (int i = 0; i < 32; i++) { //go through and send each bit in given row (32 bits in total)
                  // Set R1 and R2 based on redMap array
                  // digitalWrite(GPIOA, LED_R1, redMap[row * 32 + i]);
                  // digitalWrite(GPIOA, LED_R2, redMap[(row + 16) * 32 + i]);

                  // digitalWrite(GPIOA, LED_G1, greenMap[row * 32 + i]);
                  // digitalWrite(GPIOA, LED_G2, greenMap[(row + 16) * 32 + i]);

                  // digitalWrite(GPIOA, LED_B1, blueMap[row * 32 + i]);
                  // digitalWrite(GPIOB, LED_B2, blueMap[(row + 16) * 32 + i]);

                  digitalWrite(GPIOA, LED_B1, EmiMap[row * 32 + i]);
                  digitalWrite(GPIOB, LED_B2, EmiMap[(row + 16) * 32 + i]);

                  // Clock pulse
                  digitalWrite(GPIOB, LED_CLK, 0b1); //clock bit in
                  nano_wait(500); // Adjust this if clock speed needs to be higher
                  digitalWrite(GPIOB, LED_CLK, 0b0);
            }

            // Latch data to display the row
            digitalWrite(GPIOB, LED_LAT, 0b1);
            nano_wait(500);  // Short delay to ensure latch
            digitalWrite(GPIOB, LED_LAT, 0b0);

            // Enable output for the current row display
            digitalWrite(GPIOB, LED_OE, 0b0);
            nano_wait(500000); // Adjust this delay to control row display time
         }
      }
   }

   //-------------------------------------------------------------------------------
   // SD CARD CONFIGURATION
   //-------------------------------------------------------------------------------


   void init_usart5() {
      //Enable clocks
      RCC->AHBENR |= RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIODEN; 

      //Configure PC12 for USART5_TX (AF2)
      GPIOC->MODER |= GPIO_MODER_MODER12_1; 
      GPIOC->AFR[1] |= (2 << GPIO_AFRH_AFRH4_Pos);

      //Same for PD2
      GPIOD->MODER |= GPIO_MODER_MODER2_1; 
      GPIOD->AFR[0] |= (2 << GPIO_AFRL_AFRL2_Pos);

      //USART5 clock
      RCC->APB1ENR |= RCC_APB1ENR_USART5EN; 

      //Disable
      USART5->CR1 &= ~USART_CR1_UE; 

      //word length 8 bits
      USART5->CR1 &= ~(USART_CR1_M0 | USART_CR1_M1); 

      //stop bit 1
      USART5->CR2 &= ~USART_CR2_STOP; 

      //Noparity control
      USART5->CR1 &= ~USART_CR1_PCE; 

      //16x oversampling
      USART5->CR1 &= ~USART_CR1_OVER8; 

      //baud rate = 115200
      USART5->BRR = 0x1A1; 

      // Enable TE and RE
      USART5->CR1 |= USART_CR1_TE | USART_CR1_RE; 

      //Enable
      USART5->CR1 |= USART_CR1_UE; 

      //Wait for TEACK and REACK 
      while (!(USART5->ISR & USART_ISR_TEACK)); 
      while (!(USART5->ISR & USART_ISR_REACK)); 
   }



   #include <stdio.h>
   #include "fifo.h"
   #include "tty.h"

   #define FIFOSIZE 16
   char serfifo[FIFOSIZE];
   int seroffset = 0;
   void enable_tty_interrupt() {
      //Enable clock
      RCC->AHBENR |= RCC_AHBENR_DMA2EN;

      //Remap DMA2 Channel 2 to USART5_RX
      DMA2->CSELR |= DMA2_CSELR_CH2_USART5_RX;

      //Disable DMA Channel 2
      DMA2_Channel2->CCR &= ~DMA_CCR_EN;

      //Set memory address to serfifo
      DMA2_Channel2->CMAR = (uint32_t)serfifo;

      //Set peripheral address to USART5_RDR
      DMA2_Channel2->CPAR = (uint32_t)&USART5->RDR;

      //Data transfer size
      DMA2_Channel2->CNDTR = FIFOSIZE;

      //Configure DMA
      DMA2_Channel2->CCR &= ~DMA_CCR_MEM2MEM;
      DMA2_Channel2->CCR |= DMA_CCR_MINC;
      DMA2_Channel2->CCR &= ~DMA_CCR_PINC;
      DMA2_Channel2->CCR |= DMA_CCR_CIRC;
      DMA2_Channel2->CCR &= ~DMA_CCR_DIR;
      DMA2_Channel2->CCR |= (0 << DMA_CCR_MSIZE_Pos);
      DMA2_Channel2->CCR |= (0 << DMA_CCR_PSIZE_Pos);
      DMA2_Channel2->CCR |= DMA_CCR_PL;

      //Enable DMA Channel 2
      DMA2_Channel2->CCR |= DMA_CCR_EN;

      //Enable USART5 RXNE interrupt and DMA reception
      USART5->CR1 |= USART_CR1_RXNEIE;
      USART5->CR3 |= USART_CR3_DMAR;

      //Enable USART3-6 interrupt (USART5 shares this IRQ)
      NVIC_EnableIRQ(USART3_6_IRQn);
   }

   int interrupt_getchar(void) {
      //ait for newline in input_fifo
      while (fifo_newline(&input_fifo) == 0) {
         asm volatile ("wfi");
      }
      //Return first character from input_fifo
      return fifo_remove(&input_fifo);
   }

   int __io_putchar(int c) {
      //Handle newline, carrige return first
      if (c == '\n') {
         while (!(USART5->ISR & USART_ISR_TXE));
         USART5->TDR = '\r';
      }
      while (!(USART5->ISR & USART_ISR_TXE));
      USART5->TDR = c;
      return c;
   }

   int __io_getchar(void) {
      // Get character 
      return interrupt_getchar();
   }

   void USART3_6_IRQHandler(void) {
      // Process received from serfifo using DMA
      while (DMA2_Channel2->CNDTR != sizeof(serfifo) - seroffset) {
         if (!fifo_full(&input_fifo)) {
               insert_echo_char(serfifo[seroffset]);
         }
         seroffset = (seroffset + 1) % sizeof(serfifo);
      }
   }

   #include "commands.h"
   #include <stdio.h>


   void init_spi2_slow(void) {
      // Enable GPIOB and SPI2 clock
      RCC->AHBENR |= RCC_AHBENR_GPIOBEN; // Enable GPIOB clock
      RCC->AHBENR |= RCC_AHBENR_GPIOCEN; // Enable GPIOC clock
      RCC->APB1ENR |= RCC_APB1ENR_SPI2EN;  // Enable SPI2 clock

      // Configure PB10 as alternate function (AF5 for SPI2)
      GPIOB->MODER &= ~(GPIO_MODER_MODER10_Msk); // Clear mode
      GPIOB->MODER |= GPIO_MODER_MODER10_1;
      GPIOB->AFR[1] &= ~(GPIO_AFRH_AFSEL10_Msk);
      GPIOB->AFR[1] |= (0x5 << GPIO_AFRH_AFSEL10_Pos); // Set AF5 for SPI2

      GPIOC->MODER &= ~(GPIO_MODER_MODER2|GPIO_MODER_MODER3);
      GPIOC->MODER |= GPIO_MODER_MODER2_1 | GPIO_MODER_MODER3_1;

      GPIOC->AFR[0] &= ~(GPIO_AFRL_AFRL2_Msk|GPIO_AFRL_AFRL3_Msk);
      GPIOC->AFR[0] |= (0x1 << GPIO_AFRL_AFRL2_Pos| 0x1 << GPIO_AFRL_AFRL3_Pos);



      // Configure SPI2
      SPI2->CR1 &= ~SPI_CR1_SPE;
      SPI2->CR1 |= SPI_CR1_BR;
      SPI2->CR2 |= (0x7 << SPI_CR2_DS_Pos); // | SPI_CR2_SSOE | SPI_CR2_NSSP | SPI_CR2_TXDMAEN;
      SPI2->CR1 |= SPI_CR1_MSTR | SPI_CR1_SSM | SPI_CR1_SSI;

      // Configure FIFO reception threshold to immediately release a received value
      SPI2->CR2 |= SPI_CR2_FRXTH; // FIFO reception threshold bit

      // Enable SPI2
      SPI2->CR1 |= SPI_CR1_SPE; // Enable SPI2
   }
   void enable_sdcard(void) {
      RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
      GPIOB->BSRR = GPIO_BSRR_BR_9; // Set PB9 low to enable the SD card
   }

   void disable_sdcard(void) {
      RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
      GPIOB->BSRR = GPIO_BSRR_BS_9; // Set PB9 high to disable the SD card
   }

   void init_sdcard_io(void){
      init_spi2_slow();
      RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
      GPIOB->MODER &= ~GPIO_MODER_MODER9;
      GPIOB->MODER |= GPIO_MODER_MODER9_0;
      disable_sdcard();
   }

   void sdcard_io_high_speed(void) {
      // Disable SPI2
      SPI2->CR1 &= ~SPI_CR1_SPE; // Disable SPI2

      // Set the SPI2 Baud Rate register for 12 MHz (adjust as needed)
      SPI2->CR1 &= ~SPI_CR1_BR; // Clear baud rate bits
      SPI2->CR1 |= SPI_CR1_BR_0; // Set baud rate for f_PCLK/4 (12 MHz assuming 48 MHz PCLK)

      // Re-enable SPI2
      SPI2->CR1 |= SPI_CR1_SPE; // Enable SPI2
   }

   // -------------------------------------------------




   int main(void) {
      internal_clock();
      init_usart5();
      enable_tty_interrupt();
      setbuf(stdin,0);
      setbuf(stdout,0);
      setbuf(stderr,0);
      // command_shell();

      msg[0] = 0x0000;
      msg[1] = 0x0100;
      msg[2] = 0x0200;
      msg[3] = 0x0300;
      msg[4] = 0x0400;
      msg[5] = 0x0500;
      msg[6] = 0x0600;
      msg[7] = 0x8700;
      
      
      msg[0] |= font[' '];
      msg[1] |= font[' '];
      msg[2] |= font[' '];
      msg[3] |= font[' '];


      // msg[0] |= font['E'];
      // msg[1] |= font['C'];
      // msg[2] |= font['E'];
      // msg[3] |= font[' '];
      // msg[4] |= font['3'];
      // msg[5] |= font['6'];
      // msg[6] |= font['3'];
      // msg[7] |= font[' '];
      
      setup_bb();

      // GPIO enable
      enable_ports();

      initializeGame();

      setup_tim7_for_inputs();

      
      //init_tim16();

      init_spi1();
      spi1_init_oled();

      init_tim2();


      setup_pins();
      //trial_run();



      init_tim14();


      // for(;;) {
      //    for(int d=4; d<8; d++) {
      //       bb_write_halfword(msg[d]);
      //       //nano_wait(1000000); //1ms
      //    }
      // }
   }
#endif








//ACTUAL CODE STARTS HERE

#define EXIT_SUCCESS 0
#define THRESHOLD 3500 //THRESHOLD = Vmeasured_analog / Vref * (2^12 - 1) = 3 / 3.3 * 4095 = 3723 which is roughly 3500 (2.82V). threshold is a digital value for comparison

const char font[] = {
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x00, // 32: space
    0x86, // 33: exclamation
    0x22, // 34: double quote
    0x76, // 35: octothorpe
    0x00, // dollar
    0x00, // percent
    0x00, // ampersand
    0x20, // 39: single quote
    0x39, // 40: open paren
    0x0f, // 41: close paren
    0x49, // 42: asterisk
    0x00, // plus
    0x10, // 44: comma
    0x40, // 45: minus
    0x80, // 46: period
    0x00, // slash
    // digits
    0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x67,
    // seven unknown
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    // Uppercase
    0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71, 0x6f, 0x76, 0x30, 0x1e, 0x00, 0x38, 0x00,
    0x37, 0x3f, 0x73, 0x7b, 0x31, 0x6d, 0x78, 0x3e, 0x00, 0x00, 0x00, 0x6e, 0x00,
    0x39, // 91: open square bracket
    0x00, // backslash
    0x0f, // 93: close square bracket
    0x00, // circumflex
    0x08, // 95: underscore
    0x20, // 96: backquote
    // Lowercase
    0x5f, 0x7c, 0x58, 0x5e, 0x79, 0x71, 0x6f, 0x74, 0x10, 0x0e, 0x00, 0x30, 0x00,
    0x54, 0x5c, 0x73, 0x7b, 0x50, 0x6d, 0x78, 0x1c, 0x00, 0x00, 0x00, 0x6e, 0x00
};

//===========================================================================
// Configure All Ports
//===========================================================================
void enable_ports(void) {
   RCC->AHBENR |= RCC_AHBENR_GPIOCEN; 

   //enable PC0 for analog input and PC1-PC8 for output
   GPIOC->MODER &= ~0x0003ffff;
   GPIOC->MODER |= 0x00015557;

   //configure in ADC register
   //GPIOx_AFR H or L //analog mode

   RCC->APB2ENR |= RCC_APB2ENR_ADCEN; //ADC interface clock enable

   ADC1->CR |= ADC_CR_ADCAL; //start ADC callibration

   while (ADC1->CR & ADC_CR_ADCAL) { //wait until callibration finishes (goes low)
   }

   ADC1->CR |= ADC_CR_ADEN; //enable ADC

   //ADC1->ISR |= ADC_ISR_ADRDY; //declaring that system is ready for ADC conversion

   while (!(ADC1->ISR & ADC_ISR_ADRDY)) { //wait until ardy has been set (goes high)
   }

   ADC1->CHSELR = ADC_CHSELR_CHSEL10; //select channel for pc0 ADC

   ADC1->CR |= ADC_CR_ADSTART; //start first ADC conversion
}

uint16_t read_adc(void) {
    while (!(ADC1->ISR & ADC_ISR_EOC)){ //wait for ADC conversion to finish
    }
    return ADC1->DR;
}

volatile uint8_t goals_detected = 0;
volatile uint8_t consecutive_detections = 0;
volatile uint8_t game_won = 0;

void TIM2_IRQHandler(void) {
   //Acknowledge the interrupt by clearing the interrupt flag
   TIM2->SR &= ~TIM_SR_UIF;

   uint16_t pc0 = read_adc();
   ADC1->CR |= ADC_CR_ADSTART; //start next ADC conversion immediately for maximum time

   if (pc0 < THRESHOLD) { //low detected
      consecutive_detections = consecutive_detections + 1;
   }
   else {
      consecutive_detections = 0;
   }

   if (consecutive_detections > 19) { //low detected for 20 ms straight
      goals_detected = goals_detected + 1;
      consecutive_detections = 0;
      //GPIOC->ODR = (GPIOC->ODR & 0xfe01) | ((uint16_t)(font[goals_detected + '0']) << 1);
   }

   if (goals_detected > 9) {
      goals_detected = 0;
      game_won = 1;
   }
}

void init_tim2(void) {

   RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

   TIM2->PSC = 47;  
   TIM2->ARR = 999; 

   TIM2->DIER |= TIM_DIER_UIE;

   TIM2->CR1 |= TIM_CR1_CEN;

   NVIC_EnableIRQ(TIM2_IRQn);
}


int main(void) {

   enable_ports();
   init_tim2();

   return EXIT_SUCCESS;
}
